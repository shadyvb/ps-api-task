<?php

namespace Tests\Feature\Integration;

use App\Models\Vulnerability;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Tests\TestCase;

class VulnerabilityIntegrationTest extends TestCase
{
    use RefreshDatabase;

    public function test_can_filter_vulnerabilities_by_code()
    {
        // Arrange
        $targetVulnerability = Vulnerability::factory()->create(['code' => 'VUL-TARGET']);
        Vulnerability::factory()->count(3)->create();

        // Act
        $response = $this->getJson('/api/vulnerabilities?code=VUL-TARGET');

        // Assert
        $response->assertOk();
        $data = $response->json('data');
        $this->assertCount(1, $data);
        $this->assertEquals('VUL-TARGET', $data[0]['code']);
    }

    public function test_returns_empty_array_when_filtering_with_non_existent_code()
    {
        // Arrange
        Vulnerability::factory()->count(3)->create();

        // Act
        $response = $this->getJson('/api/vulnerabilities?code=NON-EXISTENT');

        // Assert
        $response->assertOk();
        $data = $response->json('data');
        $this->assertCount(0, $data);
    }

    public function test_can_search_vulnerabilities_by_title_or_description()
    {
        // Arrange
        $vulnerability1 = Vulnerability::factory()->create([
            'title' => 'SQL Injection Attack',
            'description' => 'Standard description',
        ]);

        $vulnerability2 = Vulnerability::factory()->create([
            'title' => 'XSS Attack',
            'description' => 'Contains SQL injection reference',
        ]);

        Vulnerability::factory()->count(3)->create();

        // Act
        $response = $this->getJson('/api/vulnerabilities?search=sql injection');

        // Assert
        $response->assertOk();
        $data = $response->json('data');
        $this->assertCount(2, $data);
        $this->assertEquals($vulnerability1->id, $data[0]['id']);
        $this->assertEquals($vulnerability2->id, $data[1]['id']);
    }

    public function test_returns_empty_array_when_search_has_no_matches()
    {
        // Arrange
        Vulnerability::factory()->count(3)->create();

        // Act
        $response = $this->getJson('/api/vulnerabilities?search=non existent text');

        // Assert
        $response->assertOk();
        $data = $response->json('data');
        $this->assertCount(0, $data);
    }

    public function test_can_paginate_vulnerabilities()
    {
        // Arrange
        Vulnerability::factory()->count(25)->create();

        // Act
        $response = $this->getJson('/api/vulnerabilities?page=2&per_page=5');

        // Assert
        $response->assertOk();
        $data = $response->json('data');
        $this->assertCount(5, $data);
        $response->assertJsonStructure([
            'current_page',
            'data',
            'first_page_url',
            'from',
            'last_page',
            'last_page_url',
            'links',
            'next_page_url',
            'path',
            'per_page',
            'prev_page_url',
            'to',
            'total',
        ]);

        $this->assertEquals(2, $response->json('current_page'));
        $this->assertEquals(5, $response->json('per_page'));
        $this->assertEquals(25, $response->json('total'));
    }

    public function test_returns_empty_array_when_page_exceeds_available_pages()
    {
        // Arrange
        Vulnerability::factory()->count(5)->create();

        // Act
        $response = $this->getJson('/api/vulnerabilities?page=3&per_page=5');

        // Assert
        $response->assertOk();
        $data = $response->json('data');
        $this->assertCount(0, $data);
        $this->assertEquals(3, $response->json('current_page'));
        $this->assertEquals(5, $response->json('per_page'));
        $this->assertEquals(5, $response->json('total'));
    }

    public function test_can_sort_vulnerabilities()
    {
        // Arrange
        $vulnerability1 = Vulnerability::factory()->create(['code' => 'VUL-001']);
        $vulnerability2 = Vulnerability::factory()->create(['code' => 'VUL-002']);
        $vulnerability3 = Vulnerability::factory()->create(['code' => 'VUL-003']);

        // Act
        $response = $this->getJson('/api/vulnerabilities?sort=-code');

        // Assert
        $response->assertOk();
        $data = $response->json('data');
        $this->assertEquals('VUL-003', $data[0]['code']);
        $this->assertEquals('VUL-002', $data[1]['code']);
        $this->assertEquals('VUL-001', $data[2]['code']);
    }

    public function test_ignores_invalid_sort_field()
    {
        // Arrange
        $vulnerability1 = Vulnerability::factory()->create(['code' => 'VUL-001']);
        $vulnerability2 = Vulnerability::factory()->create(['code' => 'VUL-002']);

        // Act
        $response = $this->getJson('/api/vulnerabilities?sort=non_existent_field');

        // Assert
        $response->assertOk();
        $data = $response->json('data');
        $this->assertCount(2, $data);
        $this->assertEquals($vulnerability1->id, $data[0]['id']);
        $this->assertEquals($vulnerability2->id, $data[1]['id']);
    }

    public function test_handles_multiple_filters_together(): void
    {
        // Arrange
        // Create vulnerabilities with different codes and titles
        Vulnerability::factory()->create([
            'code' => 'VULN-001',
            'title' => 'SQL Injection in Login Form',
            'description' => 'A vulnerability that allows SQL injection',
        ]);

        Vulnerability::factory()->create([
            'code' => 'VULN-002',
            'title' => 'XSS in Comment Form',
            'description' => 'A cross-site scripting vulnerability',
        ]);

        Vulnerability::factory()->create([
            'code' => 'VULN-003',
            'title' => 'Another SQL Injection',
            'description' => 'Another SQL injection vulnerability',
        ]);

        // Act
        $response = $this->getJson('/api/vulnerabilities?code=VULN-001&search=SQL');

        // Assert
        $response->assertStatus(200)
            ->assertJsonCount(1, 'data')
            ->assertJsonPath('data.0.code', 'VULN-001');
    }
}
